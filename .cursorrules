# Memoryys - Regras de Desenvolvimento e Configura√ß√£o de Agentes

## üö® DIRETRIZES CR√çTICAS DE PAGAMENTO

### **FILOSOFIA FUNDAMENTAL: SEGURAN√áA PRIMEIRO**
**NUNCA** aceitar pagamentos sem confirma√ß√£o real. **SEMPRE** aguardar webhook do MercadoPago.

### **üî¥ FLUXO DE PAGAMENTO CORRETO (OBRIGAT√ìRIO)**

#### **1. PR√â-PAGAMENTO**
- ‚úÖ Coletar dados do usu√°rio no frontend
- ‚úÖ Validar campos obrigat√≥rios (nome, email, telefone, tipo sangu√≠neo, contatos)
- ‚úÖ **CACHE LOCAL**: Salvar em `sessionStorage` ANTES de enviar ao backend
- ‚úÖ Coletar Device ID do MercadoPago (CR√çTICO para aprova√ß√£o)

#### **2. DURANTE PAGAMENTO**
```javascript
// CORRETO - N√ÉO REDIRECIONAR NO onSubmit
onSubmit={async (paymentData) => {
  // 1. Salvar em cache local
  sessionStorage.setItem('pendingPayment', JSON.stringify({
    ...formData,
    paymentData,
    timestamp: Date.now()
  }));
  
  // 2. Iniciar polling - N√ÉO REDIRECIONAR
  startPolling(paymentId);
  
  // 3. Para PIX - mostrar QR Code
  if (paymentData.payment_method === 'pix') {
    showPixQRCode(paymentData);
  }
}}
```

#### **3. P√ìS-PAGAMENTO**
- ‚úÖ **POLLING**: Verificar status a cada 3 segundos via `/api/check-status`
- ‚úÖ **AGUARDAR**: S√≥ redirecionar quando status = "approved"
- ‚úÖ **BANCO**: Dados s√≥ s√£o salvos ap√≥s webhook confirmar pagamento
- ‚úÖ **CLEANUP**: Limpar sessionStorage ap√≥s sucesso

### **‚ùå PR√ÅTICAS PROIBIDAS**
1. **NUNCA** chamar `onSuccess()` imediatamente no `onSubmit`
2. **NUNCA** redirecionar sem confirma√ß√£o do webhook
3. **NUNCA** salvar no banco antes do pagamento ser aprovado
4. **NUNCA** confiar apenas no retorno do Payment Brick
5. **NUNCA** ignorar a configura√ß√£o de polling do backend

## ü§ñ CONFIGURA√á√ÉO DOS AGENTES

### **frontend-agent**
**Responsabilidades:**
- Implementar polling de status de pagamento
- Cache local com sessionStorage/localStorage
- Componentes React com TypeScript strict
- Tratamento de PIX com QR Code modal
- Estado de loading durante processamento

**Regras:**
```typescript
// SEMPRE implementar polling
const pollPaymentStatus = async (paymentId: string) => {
  const maxAttempts = 40; // 2 minutos
  const interval = 3000; // 3 segundos
  
  for (let i = 0; i < maxAttempts; i++) {
    const response = await fetch(`/api/check-status?paymentId=${paymentId}`);
    const data = await response.json();
    
    if (data.status === 'approved') {
      // S√ì AGORA redirecionar
      router.push(`/success?id=${data.uniqueUrl}`);
      return;
    }
    
    if (data.status === 'rejected') {
      handlePaymentError();
      return;
    }
    
    await sleep(interval);
  }
};
```

### **backend-agent**
**Responsabilidades:**
- Endpoints de API com valida√ß√£o Zod
- Integra√ß√£o MercadoPago com Device ID
- Processamento ass√≠ncrono via QStash
- Firebase/Firestore ap√≥s confirma√ß√£o

**Regras:**
- Endpoint `/api/create-payment` retorna config de polling
- Endpoint `/api/check-status` verifica status real
- Webhook processa pagamento e atualiza status
- S√≥ salvar profile ap√≥s status = "approved"

### **payment-agent**
**Responsabilidades:**
- Device ID collection (CR√çTICO)
- HMAC validation no webhook
- Payment Brick configuration
- PIX QR Code handling

**Regras Espec√≠ficas:**
```typescript
// Device ID √© OBRIGAT√ìRIO
if (!deviceId) {
  throw new Error('Device ID missing - payment will fail');
}

// PIX precisa de tratamento especial
if (paymentMethod === 'pix') {
  // Mostrar QR Code
  // Aguardar confirma√ß√£o
  // N√£o redirecionar at√© aprovado
}
```

### **medical-validator**
**Responsabilidades:**
- Valida√ß√£o de dados m√©dicos
- LGPD compliance
- Cache seguro de dados sens√≠veis

**Regras:**
- Dados m√©dicos em sessionStorage (tempor√°rio)
- Criptografia opcional para dados sens√≠veis
- Limpeza autom√°tica ap√≥s 24h ou sucesso
- Valida√ß√£o de campos obrigat√≥rios

### **deploy-orchestrator**
**Responsabilidades:**
- Build e deploy sem quebrar fluxo
- Vari√°veis de ambiente corretas
- Testes de integra√ß√£o pagamento

**Checklist Deploy:**
- [ ] Polling implementado no frontend
- [ ] Cache local funcionando
- [ ] PIX QR Code modal implementado
- [ ] Webhook processando corretamente
- [ ] Status sendo atualizado no banco

## üìä FLUXO COMPLETO CORRETO

```mermaid
graph LR
    A[Usu√°rio preenche form] --> B[Cache em sessionStorage]
    B --> C[Coleta Device ID]
    C --> D[Envia para backend]
    D --> E[Backend cria prefer√™ncia]
    E --> F[Retorna config polling]
    F --> G[Frontend N√ÉO redireciona]
    G --> H{Tipo pagamento?}
    H -->|PIX| I[Mostra QR Code]
    H -->|Cart√£o| J[Aguarda processamento]
    I --> K[Polling status]
    J --> K
    K --> L{Status?}
    L -->|pending| K
    L -->|approved| M[Webhook salva no banco]
    M --> N[Frontend detecta aprova√ß√£o]
    N --> O[Redireciona para /success]
    L -->|rejected| P[Mostra erro]
```

## üîß IMPLEMENTA√á√ÉO IMEDIATA

### **Arquivo: src/components/MercadoPagoCheckout.tsx**
```typescript
// REMOVER linha 186-195 (onSubmit atual)
// SUBSTITUIR por:
onSubmit={async (paymentData) => {
  setProcessing(true);
  
  // 1. Cache local
  const paymentCache = {
    formData: props.formData,
    paymentData,
    uniqueUrl,
    paymentId,
    timestamp: Date.now()
  };
  sessionStorage.setItem('pendingPayment', JSON.stringify(paymentCache));
  
  // 2. PIX handling
  if (paymentData.payment_method === 'pix') {
    setShowPixModal(true);
    setPixQRCode(paymentData.qr_code);
  }
  
  // 3. Start polling - NO REDIRECT
  startPolling(paymentId, {
    onSuccess: (data) => {
      sessionStorage.removeItem('pendingPayment');
      onSuccess(data, uniqueUrl);
    },
    onError: (error) => {
      setProcessing(false);
      onError(error);
    }
  });
}}
```

### **Arquivo: src/hooks/usePaymentPolling.ts** (CRIAR)
```typescript
export const usePaymentPolling = () => {
  const [status, setStatus] = useState<PaymentStatus>('pending');
  const [polling, setPolling] = useState(false);
  
  const startPolling = useCallback(async (
    paymentId: string,
    options: PollingOptions
  ) => {
    setPolling(true);
    let attempts = 0;
    const maxAttempts = options.maxAttempts || 40;
    const interval = options.interval || 3000;
    
    const poll = async () => {
      try {
        const response = await fetch(`/api/check-status?paymentId=${paymentId}`);
        const data = await response.json();
        
        setStatus(data.status);
        
        if (data.status === 'approved') {
          options.onSuccess?.(data);
          return;
        }
        
        if (data.status === 'rejected' || data.status === 'cancelled') {
          options.onError?.(new Error(data.message));
          return;
        }
        
        if (data.status === 'pending_pix' && data.pixData) {
          options.onPixQRCode?.(data.pixData);
        }
        
        attempts++;
        if (attempts < maxAttempts && data.status === 'pending') {
          setTimeout(poll, interval);
        } else if (attempts >= maxAttempts) {
          options.onTimeout?.();
        }
      } catch (error) {
        options.onError?.(error as Error);
      }
    };
    
    // Start first poll
    setTimeout(poll, 1000);
  }, []);
  
  return { status, polling, startPolling };
};
```

## üéØ M√âTRICAS DE SUCESSO

- **Taxa de Aprova√ß√£o**: > 85% (com Device ID)
- **Pagamentos Falsos**: 0%
- **PIX Funcional**: 100%
- **Cache Recovery**: 100% dos dados recuper√°veis
- **Timeout Handling**: M√°ximo 2 minutos de espera

## üìù NOTAS IMPORTANTES

1. **Device ID √© CR√çTICO**: Sem ele, aprova√ß√£o cai de 85% para 40%
2. **PIX precisa QR Code**: Mostrar ANTES de qualquer redirecionamento
3. **Polling √© OBRIGAT√ìRIO**: Backend j√° est√° pronto, frontend precisa implementar
4. **Cache local SEMPRE**: Previne perda de dados em caso de erro
5. **Webhook √© a VERDADE**: S√≥ ele confirma pagamento real

---

**√öltima Atualiza√ß√£o**: 24/08/2025
**Vers√£o**: 2.0 - Alinhado com estrat√©gia de polling e cache local
**Status**: CR√çTICO - Implementar imediatamente